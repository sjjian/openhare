// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'mysql.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$QueryValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QueryValueCopyWith<$Res> {
  factory $QueryValueCopyWith(
          QueryValue value, $Res Function(QueryValue) then) =
      _$QueryValueCopyWithImpl<$Res, QueryValue>;
}

/// @nodoc
class _$QueryValueCopyWithImpl<$Res, $Val extends QueryValue>
    implements $QueryValueCopyWith<$Res> {
  _$QueryValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$QueryValue_NULLImplCopyWith<$Res> {
  factory _$$QueryValue_NULLImplCopyWith(_$QueryValue_NULLImpl value,
          $Res Function(_$QueryValue_NULLImpl) then) =
      __$$QueryValue_NULLImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QueryValue_NULLImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_NULLImpl>
    implements _$$QueryValue_NULLImplCopyWith<$Res> {
  __$$QueryValue_NULLImplCopyWithImpl(
      _$QueryValue_NULLImpl _value, $Res Function(_$QueryValue_NULLImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$QueryValue_NULLImpl extends QueryValue_NULL {
  const _$QueryValue_NULLImpl() : super._();

  @override
  String toString() {
    return 'QueryValue.null_()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QueryValue_NULLImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return null_();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return null_?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return null_(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return null_?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_(this);
    }
    return orElse();
  }
}

abstract class QueryValue_NULL extends QueryValue {
  const factory QueryValue_NULL() = _$QueryValue_NULLImpl;
  const QueryValue_NULL._() : super._();
}

/// @nodoc
abstract class _$$QueryValue_BytesImplCopyWith<$Res> {
  factory _$$QueryValue_BytesImplCopyWith(_$QueryValue_BytesImpl value,
          $Res Function(_$QueryValue_BytesImpl) then) =
      __$$QueryValue_BytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$QueryValue_BytesImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_BytesImpl>
    implements _$$QueryValue_BytesImplCopyWith<$Res> {
  __$$QueryValue_BytesImplCopyWithImpl(_$QueryValue_BytesImpl _value,
      $Res Function(_$QueryValue_BytesImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_BytesImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$QueryValue_BytesImpl extends QueryValue_Bytes {
  const _$QueryValue_BytesImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'QueryValue.bytes(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_BytesImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_BytesImplCopyWith<_$QueryValue_BytesImpl> get copyWith =>
      __$$QueryValue_BytesImplCopyWithImpl<_$QueryValue_BytesImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return bytes(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return bytes?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class QueryValue_Bytes extends QueryValue {
  const factory QueryValue_Bytes(final Uint8List field0) =
      _$QueryValue_BytesImpl;
  const QueryValue_Bytes._() : super._();

  Uint8List get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_BytesImplCopyWith<_$QueryValue_BytesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QueryValue_IntImplCopyWith<$Res> {
  factory _$$QueryValue_IntImplCopyWith(_$QueryValue_IntImpl value,
          $Res Function(_$QueryValue_IntImpl) then) =
      __$$QueryValue_IntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$QueryValue_IntImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_IntImpl>
    implements _$$QueryValue_IntImplCopyWith<$Res> {
  __$$QueryValue_IntImplCopyWithImpl(
      _$QueryValue_IntImpl _value, $Res Function(_$QueryValue_IntImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_IntImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$QueryValue_IntImpl extends QueryValue_Int {
  const _$QueryValue_IntImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'QueryValue.int(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_IntImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_IntImplCopyWith<_$QueryValue_IntImpl> get copyWith =>
      __$$QueryValue_IntImplCopyWithImpl<_$QueryValue_IntImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return int(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return int?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return int(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return int?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (int != null) {
      return int(this);
    }
    return orElse();
  }
}

abstract class QueryValue_Int extends QueryValue {
  const factory QueryValue_Int(final int field0) = _$QueryValue_IntImpl;
  const QueryValue_Int._() : super._();

  int get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_IntImplCopyWith<_$QueryValue_IntImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QueryValue_UIntImplCopyWith<$Res> {
  factory _$$QueryValue_UIntImplCopyWith(_$QueryValue_UIntImpl value,
          $Res Function(_$QueryValue_UIntImpl) then) =
      __$$QueryValue_UIntImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BigInt field0});
}

/// @nodoc
class __$$QueryValue_UIntImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_UIntImpl>
    implements _$$QueryValue_UIntImplCopyWith<$Res> {
  __$$QueryValue_UIntImplCopyWithImpl(
      _$QueryValue_UIntImpl _value, $Res Function(_$QueryValue_UIntImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_UIntImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$QueryValue_UIntImpl extends QueryValue_UInt {
  const _$QueryValue_UIntImpl(this.field0) : super._();

  @override
  final BigInt field0;

  @override
  String toString() {
    return 'QueryValue.uInt(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_UIntImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_UIntImplCopyWith<_$QueryValue_UIntImpl> get copyWith =>
      __$$QueryValue_UIntImplCopyWithImpl<_$QueryValue_UIntImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return uInt(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return uInt?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (uInt != null) {
      return uInt(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return uInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return uInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (uInt != null) {
      return uInt(this);
    }
    return orElse();
  }
}

abstract class QueryValue_UInt extends QueryValue {
  const factory QueryValue_UInt(final BigInt field0) = _$QueryValue_UIntImpl;
  const QueryValue_UInt._() : super._();

  BigInt get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_UIntImplCopyWith<_$QueryValue_UIntImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QueryValue_FloatImplCopyWith<$Res> {
  factory _$$QueryValue_FloatImplCopyWith(_$QueryValue_FloatImpl value,
          $Res Function(_$QueryValue_FloatImpl) then) =
      __$$QueryValue_FloatImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$QueryValue_FloatImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_FloatImpl>
    implements _$$QueryValue_FloatImplCopyWith<$Res> {
  __$$QueryValue_FloatImplCopyWithImpl(_$QueryValue_FloatImpl _value,
      $Res Function(_$QueryValue_FloatImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_FloatImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$QueryValue_FloatImpl extends QueryValue_Float {
  const _$QueryValue_FloatImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'QueryValue.float(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_FloatImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_FloatImplCopyWith<_$QueryValue_FloatImpl> get copyWith =>
      __$$QueryValue_FloatImplCopyWithImpl<_$QueryValue_FloatImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return float(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return float?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return float(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return float?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (float != null) {
      return float(this);
    }
    return orElse();
  }
}

abstract class QueryValue_Float extends QueryValue {
  const factory QueryValue_Float(final double field0) = _$QueryValue_FloatImpl;
  const QueryValue_Float._() : super._();

  double get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_FloatImplCopyWith<_$QueryValue_FloatImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QueryValue_DoubleImplCopyWith<$Res> {
  factory _$$QueryValue_DoubleImplCopyWith(_$QueryValue_DoubleImpl value,
          $Res Function(_$QueryValue_DoubleImpl) then) =
      __$$QueryValue_DoubleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$QueryValue_DoubleImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_DoubleImpl>
    implements _$$QueryValue_DoubleImplCopyWith<$Res> {
  __$$QueryValue_DoubleImplCopyWithImpl(_$QueryValue_DoubleImpl _value,
      $Res Function(_$QueryValue_DoubleImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_DoubleImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$QueryValue_DoubleImpl extends QueryValue_Double {
  const _$QueryValue_DoubleImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'QueryValue.double(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_DoubleImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_DoubleImplCopyWith<_$QueryValue_DoubleImpl> get copyWith =>
      __$$QueryValue_DoubleImplCopyWithImpl<_$QueryValue_DoubleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return double(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return double?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return double(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return double?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (double != null) {
      return double(this);
    }
    return orElse();
  }
}

abstract class QueryValue_Double extends QueryValue {
  const factory QueryValue_Double(final double field0) =
      _$QueryValue_DoubleImpl;
  const QueryValue_Double._() : super._();

  double get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_DoubleImplCopyWith<_$QueryValue_DoubleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$QueryValue_DateTimeImplCopyWith<$Res> {
  factory _$$QueryValue_DateTimeImplCopyWith(_$QueryValue_DateTimeImpl value,
          $Res Function(_$QueryValue_DateTimeImpl) then) =
      __$$QueryValue_DateTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$QueryValue_DateTimeImplCopyWithImpl<$Res>
    extends _$QueryValueCopyWithImpl<$Res, _$QueryValue_DateTimeImpl>
    implements _$$QueryValue_DateTimeImplCopyWith<$Res> {
  __$$QueryValue_DateTimeImplCopyWithImpl(_$QueryValue_DateTimeImpl _value,
      $Res Function(_$QueryValue_DateTimeImpl) _then)
      : super(_value, _then);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$QueryValue_DateTimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$QueryValue_DateTimeImpl extends QueryValue_DateTime {
  const _$QueryValue_DateTimeImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'QueryValue.dateTime(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryValue_DateTimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryValue_DateTimeImplCopyWith<_$QueryValue_DateTimeImpl> get copyWith =>
      __$$QueryValue_DateTimeImplCopyWithImpl<_$QueryValue_DateTimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(Uint8List field0) bytes,
    required TResult Function(int field0) int,
    required TResult Function(BigInt field0) uInt,
    required TResult Function(double field0) float,
    required TResult Function(double field0) double,
    required TResult Function(int field0) dateTime,
  }) {
    return dateTime(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(Uint8List field0)? bytes,
    TResult? Function(int field0)? int,
    TResult? Function(BigInt field0)? uInt,
    TResult? Function(double field0)? float,
    TResult? Function(double field0)? double,
    TResult? Function(int field0)? dateTime,
  }) {
    return dateTime?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(Uint8List field0)? bytes,
    TResult Function(int field0)? int,
    TResult Function(BigInt field0)? uInt,
    TResult Function(double field0)? float,
    TResult Function(double field0)? double,
    TResult Function(int field0)? dateTime,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(QueryValue_NULL value) null_,
    required TResult Function(QueryValue_Bytes value) bytes,
    required TResult Function(QueryValue_Int value) int,
    required TResult Function(QueryValue_UInt value) uInt,
    required TResult Function(QueryValue_Float value) float,
    required TResult Function(QueryValue_Double value) double,
    required TResult Function(QueryValue_DateTime value) dateTime,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(QueryValue_NULL value)? null_,
    TResult? Function(QueryValue_Bytes value)? bytes,
    TResult? Function(QueryValue_Int value)? int,
    TResult? Function(QueryValue_UInt value)? uInt,
    TResult? Function(QueryValue_Float value)? float,
    TResult? Function(QueryValue_Double value)? double,
    TResult? Function(QueryValue_DateTime value)? dateTime,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(QueryValue_NULL value)? null_,
    TResult Function(QueryValue_Bytes value)? bytes,
    TResult Function(QueryValue_Int value)? int,
    TResult Function(QueryValue_UInt value)? uInt,
    TResult Function(QueryValue_Float value)? float,
    TResult Function(QueryValue_Double value)? double,
    TResult Function(QueryValue_DateTime value)? dateTime,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class QueryValue_DateTime extends QueryValue {
  const factory QueryValue_DateTime(final int field0) =
      _$QueryValue_DateTimeImpl;
  const QueryValue_DateTime._() : super._();

  int get field0;

  /// Create a copy of QueryValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryValue_DateTimeImplCopyWith<_$QueryValue_DateTimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
